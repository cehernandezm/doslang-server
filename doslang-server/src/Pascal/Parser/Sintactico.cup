package Pascal.Parser;

import java_cup.runtime.*;
import Pascal.Analisis.*;
import Pascal.Analisis.TipoDato.*;
import Pascal.Componentes.*;
import Pascal.Componentes.UserTypes.*;
import java.util.LinkedList;

parser code
{:

	public static LinkedList<Instruccion> lista;

	

	public  void setLista(LinkedList<Instruccion> listaG){
		lista = listaG;
	}

	public  LinkedList<Instruccion> getLista(){
		return lista;
	}
	
	public static int cont=0;
	public void syntax_error(Symbol s){
        System.err.println("Error Sintáctico en la Línea " + (s.left) +" Columna "+s.right+ ". No se esperaba este componente: " +s.value+".");
	}

	 public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        System.err.println("Error síntactico irrecuperable en la Línea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido.");
    }
:}

terminal UMENOS;
terminal MAS,MENOS,POR,DIVIDIDO,MODULO,POTENCIA;
terminal SALUDO,ID,ENTERO,DECIMAL;
terminal PARIZQ,PARDER,PNTCOMA,DSPUNTOS,COMA;

terminal CHAR,CADENA,TRUE,FALSE;

terminal MAYOR,MENOR,MAYORIGUAL,MENORIGUAL, IGUAL, DIFERENTE;
terminal AND, OR, NAND, NOR,NOT;
terminal RNOT;

terminal PROGRAM,CONST;

terminal INTEGER,BOOLEAN,REAL,STRING,WORD;

terminal TYPE;



non terminal LinkedList<Instruccion> inicio;

non terminal Expresion expresion;

non terminal insNombrePrograma;

non terminal Type tipoDato;
non terminal LinkedList<String> listaID;

//------------------------------------------------------------ NO TERMINALES PARA CONSTANTES ---------------------------------------
non terminal LinkedList<Instruccion> listaDeclaracionConstantes;
non terminal Declaracion declaracionConstante;
non terminal LinkedList<Instruccion> insConstantes;
non terminal LinkedList<Instruccion> insType;
non terminal TypeDeclaration equivalencia;
non terminal LinkedList<Instruccion> listaType;


//----------------------------------------------------------------------- PRECEDENCIA RELACIONALES ----------------------------------------------------
precedence left OR;
precedence left NAND, NOR;
precedence left AND;
precedence right RNOT;
precedence left MAYOR,MENOR,MAYORIGUAL,MENORIGUAL, IGUAL,DIFERENTE;

//----------------------------------------------------------------------- PRECEDENCIA OPERADORES ------------------------------------------------------
precedence left MAS,MENOS;
precedence left POR,DIVIDIDO,MODULO;
precedence left POTENCIA;
precedence right UMENOS;


start with inicio;


inicio ::= insNombrePrograma insType:a										{: RESULT = new LinkedList<Instruccion>(); RESULT.addAll(a); setLista(RESULT); :}
          ;




//------------------------------------------------------------ NOMBRE DE UN PROGRAMA ---------------------------------------------------------
insNombrePrograma ::= PROGRAM ID PNTCOMA
                    ;

//--------------------------------------------------------- CONSTANTE | CONSTANTE FUNCIONES ---------------------------------------------------------
insConstantes ::= CONST listaDeclaracionConstantes:a 					{: RESULT = a; :}
				;

//--------------------------------------------------------- TYPE | TYPE CONSTANTES ---------------------------------------------------------------
insType ::= TYPE listaType:a 										{: RESULT = a; :}
		  | TYPE listaType:a insConstantes:b 				        {: RESULT = a; RESULT.addAll(b); :}
		  | insConstantes:a 				                        {: RESULT = a; :}
		  | error PNTCOMA 										{: RESULT = new LinkedList<Instruccion>(); :}
          ;				

listaType ::= listaType:a equivalencia:b 							{: RESULT = a; RESULT.addLast(b); :}
			| equivalencia:a 										{: RESULT = new LinkedList<>(); RESULT.addLast(a); :}
			;  								   

equivalencia ::= listaID:a IGUAL tipoDato:b PNTCOMA 					{: RESULT = new TypeDeclaration(a,aleft,aright,b); :}
			   | listaID:a PNTCOMA									{: RESULT = new TypeDeclaration(a,aleft,aright,null); :}
			   ;

listaDeclaracionConstantes ::= listaDeclaracionConstantes:a declaracionConstante:b          {: RESULT = a; RESULT.addLast(b); :} 
						     | declaracionConstante:a 									    {: RESULT = new LinkedList<Instruccion>(); RESULT.addLast(a);  :}
						     ;


declaracionConstante ::= listaID:a DSPUNTOS tipoDato:b IGUAL expresion:c PNTCOMA   			{: RESULT = new Declaracion(c,bleft,bright,true,b,a); :} 					
					   ;


//---------------------------------------------- TIPOS DE DATOS -------------------------------------------------------------------------
tipoDato ::= INTEGER:a 									{: RESULT = new Type(a.toString(),Tipo.INT); :}
		   | BOOLEAN:a 									{: RESULT = new Type(a.toString(),Tipo.BOOLEAN); :}
		   | REAL:a 									{: RESULT = new Type(a.toString(),Tipo.DOUBLE); :}
		   | CHAR:a 									{: RESULT = new Type(a.toString(),Tipo.CHAR); :}
		   | WORD:a 									{: RESULT = new Type(a.toString(),Tipo.WORD); :}
		   | STRING:a 									{: RESULT = new Type(a.toString(),Tipo.STRING); :}
		   | ID:a 										{: RESULT = new Type(a.toString(),Tipo.ID); :}

		   ;

//------------------------------------------------ LISTAS DE ID -------------------------------------------------------------------------
listaID ::= listaID:a COMA ID:b 						{: RESULT = a; RESULT.addLast(b.toString()); :}
	      | ID:a 									    {: RESULT = new LinkedList<String>(); RESULT.addLast(a.toString()); :}
	      ;


expresion ::= expresion:a MAS expresion:b 											 {: RESULT = new Expresion(a,b,Operacion.SUMA,aleft,aright);  :} 
			| expresion:a MENOS expresion:b 										 {: RESULT = new Expresion(a,b,Operacion.RESTA,aleft,aright); :}
			| expresion:a POR expresion:b 										     {: RESULT = new Expresion(a,b,Operacion.MULTIPLICACION,aleft,aright); :}
			| expresion:a DIVIDIDO expresion:b 										 {: RESULT = new Expresion(a,b,Operacion.DIVISION,aleft,aright); :}	 
			| expresion:a MODULO expresion:b 										 {: RESULT = new Expresion(a,b,Operacion.MODULO,aleft,aright); :}
			| expresion:a POTENCIA expresion:b 										 {: RESULT = new Expresion(a,b,Operacion.POTENCIA,aleft,aright); :}
			| expresion:a MAYOR expresion:b 										 {: RESULT = new Expresion(a,b,Operacion.MAYOR,aleft,aright); :}
			| expresion:a MENOR expresion:b 										 {: RESULT = new Expresion(a,b,Operacion.MENOR,aleft,aright); :}
			| expresion:a MAYORIGUAL expresion:b 								     {: RESULT = new Expresion(a,b,Operacion.MAYORIGUAL,aleft,aright); :}
			| expresion:a MENORIGUAL expresion:b 								     {: RESULT = new Expresion(a,b,Operacion.MENORIGUAL,aleft,aright); :}
			| expresion:a IGUAL expresion:b 								         {: RESULT = new Expresion(a,b,Operacion.IGUAL,aleft,aright); :}
			| expresion:a DIFERENTE expresion:b 								     {: RESULT = new Expresion(a,b,Operacion.DIFERENTE,aleft,aright); :}
			| expresion:a AND expresion:b 		  	 							     {: RESULT = new Expresion(a,b,Operacion.AND,aleft,aright); :}
			| expresion:a OR expresion:b 		  	 							     {: RESULT = new Expresion(a,b,Operacion.OR,aleft,aright); :}
			| expresion:a NAND expresion:b 		  	 							     {: RESULT = new Expresion(a,b,Operacion.NAND,aleft,aright); :}
			| expresion:a NOR expresion:b 		  	 							     {: RESULT = new Expresion(a,b,Operacion.NOR,aleft,aright); :}
		    |             NOT expresion:a 											 {: RESULT = new Expresion(a,null,Operacion.NOT,aleft,aright); :} %prec RNOT
		    | PARIZQ expresion:a PARDER                                              {: RESULT = a; :}
			| ENTERO:a 																 {: RESULT = new Expresion(a,Tipo.INT,aleft,aright); :}
			| DECIMAL:a 															 {: RESULT = new Expresion(a,Tipo.DOUBLE,aleft,aright); :}
			| CHAR:a 																 {: RESULT = new Expresion(a,Tipo.CHAR,aleft,aright); :}
			| CADENA:a 															     {: RESULT = new Expresion(a,Tipo.STRING,aleft,aright); :}
			| TRUE:a															     {: RESULT = new Expresion(a,Tipo.BOOLEAN,aleft,aright); :}
			| FALSE:a 															     {: RESULT = new Expresion(a,Tipo.BOOLEAN,aleft,aright); :}
			;


